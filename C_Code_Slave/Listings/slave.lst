C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SLAVE
OBJECT MODULE PLACED IN .\Objects\slave.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE slave.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE SYM
                    -BOLS PRINT(.\Listings\slave.lst) TABS(2) PREPRINT(.\Listings\slave.i) OBJECT(.\Objects\slave.obj)

line level    source

   1          #include "..\stdint.h"
   1      =1  /*-------------------------------------------------------------------------
   2      =1     stdint.h - ISO C99 7.18 Integer types <stdint.h>
   3      =1  
   4      =1     Copyright (C) 2005, Maarten Brock, sourceforge.brock@dse.nl
   5      =1     Copyright (C) 2011, Philipp Klaus Krause, pkk@spth.de
   6      =1  
   7      =1     This library is free software; you can redistribute it and/or modify it
   8      =1     under the terms of the GNU General Public License as published by the
   9      =1     Free Software Foundation; either version 2, or (at your option) any
  10      =1     later version.
  11      =1  
  12      =1     This library is distributed in the hope that it will be useful,
  13      =1     but WITHOUT ANY WARRANTY; without even the implied warranty of
  14      =1     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15      =1     GNU General Public License for more details.
  16      =1  
  17      =1     You should have received a copy of the GNU General Public License 
  18      =1     along with this library; see the file COPYING. If not, write to the
  19      =1     Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
  20      =1     MA 02110-1301, USA.
  21      =1  
  22      =1     As a special exception, if you link this library with other files,
  23      =1     some of which are compiled with SDCC, to produce an executable,
  24      =1     this library does not by itself cause the resulting executable to
  25      =1     be covered by the GNU General Public License. This exception does
  26      =1     not however invalidate any other reasons why the executable file
  27      =1     might be covered by the GNU General Public License.
  28      =1  -------------------------------------------------------------------------*/
  29      =1  
  30      =1  #ifndef _STDINT_H
  31      =1  #define _STDINT_H       1
  32      =1  
  33      =1  /* Exact integral types.  */
  34      =1  
  35      =1  #if !defined(__SDCC_pic14) && !defined(__SDCC_pic16)
  36      =1  #if __STDC_VERSION__ >= 199901L
*** WARNING C322 IN LINE 36 OF ..\stdint.h: unknown identifier
           =1 #define __SDCC_LONGLONG
           =1 #endif
  39      =1  #endif
  40      =1  
  41      =1  /* Signed.  */
  42      =1  
  43      =1  typedef signed char             int8_t;
  44      =1  typedef short int               int16_t;
  45      =1  typedef long int                int32_t;
  46      =1  #ifdef __SDCC_LONGLONG
           =1 typedef long long int           int64_t;
           =1 #endif
  49      =1  
  50      =1  /* Unsigned.  */
  51      =1  typedef unsigned char           uint8_t;
  52      =1  typedef unsigned short int      uint16_t;
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 2   

  53      =1  typedef unsigned long int       uint32_t;
  54      =1  #ifdef __SDCC_LONGLONG
           =1 typedef unsigned long long int  uint64_t;
           =1 #endif
  57      =1  
  58      =1  /* Small types.  */
  59      =1  
  60      =1  /* Signed.  */
  61      =1  typedef signed char             int_least8_t;
  62      =1  typedef short int               int_least16_t;
  63      =1  typedef long int                int_least32_t;
  64      =1  #ifdef __SDCC_LONGLONG
           =1 typedef long long int           int_least64_t;
           =1 #endif
  67      =1  
  68      =1  /* Unsigned.  */
  69      =1  typedef unsigned char           uint_least8_t;
  70      =1  typedef unsigned short int      uint_least16_t;
  71      =1  typedef unsigned long int       uint_least32_t;
  72      =1  #ifdef __SDCC_LONGLONG
           =1 typedef unsigned long long int  uint_least64_t;
           =1 #endif
  75      =1  
  76      =1  /* Fast types.  */
  77      =1  
  78      =1  /* Signed.  */
  79      =1  typedef signed char             int_fast8_t;
  80      =1  typedef int                     int_fast16_t;
  81      =1  typedef long int                int_fast32_t;
  82      =1  #ifdef __SDCC_LONGLONG
           =1 typedef long long int           int_fast64_t;
           =1 #endif
  85      =1  
  86      =1  /* Unsigned.  */
  87      =1  typedef unsigned char           uint_fast8_t;
  88      =1  typedef unsigned int            uint_fast16_t;
  89      =1  typedef unsigned long int       uint_fast32_t;
  90      =1  #ifdef __SDCC_LONGLONG
           =1 typedef unsigned long long int  uint_fast64_t;
           =1 #endif
  93      =1  
  94      =1  /* Types for `void *' pointers.  */
  95      =1  #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =1   typedef long int              intptr_t;
           =1   typedef unsigned long int     uintptr_t;
           =1 #else
  99      =1    typedef int                   intptr_t;
 100      =1    typedef unsigned int          uintptr_t;
 101      =1  #endif
 102      =1  
 103      =1  
 104      =1  /* Largest integral types.  */
 105      =1  #ifndef __SDCC_LONGLONG
 106      =1  typedef long int                intmax_t;
 107      =1  typedef unsigned long int       uintmax_t;
 108      =1  #else
           =1 typedef long long int           intmax_t;
           =1 typedef unsigned long long int  uintmax_t;
           =1 #endif
 112      =1  
 113      =1  /* Limits of integral types.  */
 114      =1  
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 3   

 115      =1  /* Minimum of signed integral types.  */
 116      =1  #define INT8_MIN               (-128)
 117      =1  #define INT16_MIN              (-32767-1)
 118      =1  #define INT32_MIN              (-2147483647L-1)
 119      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT64_MIN              (-9223372036854775807LL-1)
           =1 #endif
 122      =1  
 123      =1  /* Maximum of signed integral types.  */
 124      =1  #define INT8_MAX               (127)
 125      =1  #define INT16_MAX              (32767)
 126      =1  #define INT32_MAX              (2147483647L)
 127      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT64_MAX              (9223372036854775807LL)
           =1 #endif
 130      =1  
 131      =1  /* Maximum of unsigned integral types.  */
 132      =1  #define UINT8_MAX              (255)
 133      =1  #define UINT16_MAX             (65535)
 134      =1  #define UINT32_MAX             (4294967295UL)
 135      =1  #ifdef __SDCC_LONGLONG
           =1 #define UINT64_MAX             (18446744073709551615ULL)
           =1 #endif
 138      =1  
 139      =1  /* Minimum of signed integral types having a minimum size.  */
 140      =1  #define INT_LEAST8_MIN         INT8_MIN
 141      =1  #define INT_LEAST16_MIN        INT16_MIN
 142      =1  #define INT_LEAST32_MIN        INT32_MIN
 143      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT_LEAST64_MIN        INT64_MIN
           =1 #endif
 146      =1  
 147      =1  /* Maximum of signed integral types having a minimum size.  */
 148      =1  #define INT_LEAST8_MAX         INT8_MAX
 149      =1  #define INT_LEAST16_MAX        INT16_MAX
 150      =1  #define INT_LEAST32_MAX        INT32_MAX
 151      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT_LEAST64_MAX        INT64_MAX
           =1 #endif
 154      =1  
 155      =1  /* Maximum of unsigned integral types having a minimum size.  */
 156      =1  #define UINT_LEAST8_MAX        UINT8_MAX
 157      =1  #define UINT_LEAST16_MAX       UINT16_MAX
 158      =1  #define UINT_LEAST32_MAX       UINT32_MAX
 159      =1  #ifdef __SDCC_LONGLONG
           =1 #define UINT_LEAST64_MAX       UINT64_MAX
           =1 #endif
 162      =1  
 163      =1  /* Minimum of fast signed integral types having a minimum size.  */
 164      =1  #define INT_FAST8_MIN          INT8_MIN
 165      =1  #define INT_FAST16_MIN         INT16_MIN
 166      =1  #define INT_FAST32_MIN         INT32_MIN
 167      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT_FAST64_MIN         INT64_MIN
           =1 #endif
 170      =1  
 171      =1  /* Maximum of fast signed integral types having a minimum size.  */
 172      =1  #define INT_FAST8_MAX          INT8_MAX
 173      =1  #define INT_FAST16_MAX         INT16_MAX
 174      =1  #define INT_FAST32_MAX         INT32_MAX
 175      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT_FAST64_MAX         INT64_MAX
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 4   

           =1 #endif
 178      =1  
 179      =1  /* Maximum of fast unsigned integral types having a minimum size.  */
 180      =1  #define UINT_FAST8_MAX         UINT8_MAX
 181      =1  #define UINT_FAST16_MAX        UINT16_MAX
 182      =1  #define UINT_FAST32_MAX        UINT32_MAX
 183      =1  #ifdef __SDCC_LONGLONG
           =1 #define UINT_FAST64_MAX        UINT64_MAX
           =1 #endif
 186      =1  
 187      =1  /* Values to test for integral types holding `void *' pointer.  */
 188      =1  #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =1 #define INTPTR_MIN             (-2147483647L-1)
           =1 #define INTPTR_MAX             (2147483647L)
           =1 #define UINTPTR_MAX            (4294967295UL)
           =1 #else
 193      =1  #define INTPTR_MIN             (-32767-1)
 194      =1  #define INTPTR_MAX             (32767)
 195      =1  #define UINTPTR_MAX            (65535)
 196      =1  #endif
 197      =1  
 198      =1  /* Minimum for largest signed integral type.  */
 199      =1  #ifndef __SDCC_LONGLONG
 200      =1  #define INTMAX_MIN             (-2147483647L-1)
 201      =1  #else
           =1 #define INTMAX_MIN             (-9223372036854775807LL-1)
           =1 #endif
 204      =1  
 205      =1  /* Maximum for largest signed integral type.  */
 206      =1  #ifndef __SDCC_LONGLONG
 207      =1  #define INTMAX_MAX             (2147483647L)
 208      =1  #else
           =1 #define INTMAX_MAX             (9223372036854775807LL)
           =1 #endif
 211      =1  
 212      =1  /* Maximum for largest unsigned integral type.  */
 213      =1  #ifndef __SDCC_LONGLONG
 214      =1  #define UINTMAX_MAX            (4294967295UL)
 215      =1  #else
           =1 #define UINTMAX_MAX            (18446744073709551615ULL)
           =1 #endif
 218      =1  
 219      =1  /* Limits of other integer types.  */
 220      =1  
 221      =1  /* Limits of `ptrdiff_t' type.  */
 222      =1  #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =1 #define PTRDIFF_MIN           (-2147483647L-1)
           =1 #define PTRDIFF_MAX           (2147483647L)
           =1 #else
 226      =1  #define PTRDIFF_MIN           (-32767-1)
 227      =1  #define PTRDIFF_MAX           (32767)
 228      =1  #endif
 229      =1  
 230      =1  /* */
 231      =1  #define SIG_ATOMIC_MIN        (0)
 232      =1  #define SIG_ATOMIC_MAX        (255)
 233      =1  
 234      =1  /* Limit of `size_t' type.  */
 235      =1  #define SIZE_MAX               (65535u)
 236      =1  
 237      =1  /* Signed.  */
 238      =1  #define INT8_C(c)      c
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 5   

 239      =1  #define INT16_C(c)     c
 240      =1  #define INT32_C(c)     c ## L
 241      =1  #ifdef __SDCC_LONGLONG
           =1 #define INT64_C(c)     c ## LL
           =1 #endif
 244      =1  
 245      =1  /* Unsigned.  */
 246      =1  #define UINT8_C(c)     c ## U
 247      =1  #define UINT16_C(c)    c ## U
 248      =1  #define UINT32_C(c)    c ## UL
 249      =1  #ifdef __SDCC_LONGLONG
           =1 #define UINT64_C(c)    c ## ULL
           =1 #endif
 252      =1  
 253      =1  #define WCHAR_MIN      0
 254      =1  #define WCHAR_MAX      0xffffffff
 255      =1  
 256      =1  #define WINT_MIN       0
 257      =1  #define WINT_MAX       0xffffffff
 258      =1  
 259      =1  /* Maximal type.  */
 260      =1  #ifdef __SDCC_LONGLONG
           =1 #define INTMAX_C(c)    c ## LL
           =1 #define UINTMAX_C(c)   c ## ULL
           =1 #else
 264      =1  #define INTMAX_C(c)    c ## L
 265      =1  #define UINTMAX_C(c)   c ## UL
 266      =1  #endif
 267      =1  
 268      =1  /* Bounds-checking interfaces from annex K of the C11 standard. */
 269      =1  #if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__
           =1 #define RSIZE_MAX SIZE_MAX
           =1 #endif
 272      =1  
 273      =1  #endif /* stdint.h */
 274      =1  
   2          #include "slave.h"
   1      =1  
   2      =1  #ifndef __MODBUS_SLAVE_H__
   3      =1  #define __MODBUS_SLAVE_H__
   4      =1  
   5      =1  #include "..\stdint.h"
   1      =2  /*-------------------------------------------------------------------------
   2      =2     stdint.h - ISO C99 7.18 Integer types <stdint.h>
   3      =2  
   4      =2     Copyright (C) 2005, Maarten Brock, sourceforge.brock@dse.nl
   5      =2     Copyright (C) 2011, Philipp Klaus Krause, pkk@spth.de
   6      =2  
   7      =2     This library is free software; you can redistribute it and/or modify it
   8      =2     under the terms of the GNU General Public License as published by the
   9      =2     Free Software Foundation; either version 2, or (at your option) any
  10      =2     later version.
  11      =2  
  12      =2     This library is distributed in the hope that it will be useful,
  13      =2     but WITHOUT ANY WARRANTY; without even the implied warranty of
  14      =2     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15      =2     GNU General Public License for more details.
  16      =2  
  17      =2     You should have received a copy of the GNU General Public License 
  18      =2     along with this library; see the file COPYING. If not, write to the
  19      =2     Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
  20      =2     MA 02110-1301, USA.
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 6   

  21      =2  
  22      =2     As a special exception, if you link this library with other files,
  23      =2     some of which are compiled with SDCC, to produce an executable,
  24      =2     this library does not by itself cause the resulting executable to
  25      =2     be covered by the GNU General Public License. This exception does
  26      =2     not however invalidate any other reasons why the executable file
  27      =2     might be covered by the GNU General Public License.
  28      =2  -------------------------------------------------------------------------*/
  29      =2  
  30      =2  #ifndef _STDINT_H
           =2 #define _STDINT_H       1
           =2 
           =2 /* Exact integral types.  */
           =2 
           =2 #if !defined(__SDCC_pic14) && !defined(__SDCC_pic16)
           =2 #if __STDC_VERSION__ >= 199901L
           =2 #define __SDCC_LONGLONG
           =2 #endif
           =2 #endif
           =2 
           =2 /* Signed.  */
           =2 
           =2 typedef signed char             int8_t;
           =2 typedef short int               int16_t;
           =2 typedef long int                int32_t;
           =2 #ifdef __SDCC_LONGLONG
           =2 typedef long long int           int64_t;
           =2 #endif
           =2 
           =2 /* Unsigned.  */
           =2 typedef unsigned char           uint8_t;
           =2 typedef unsigned short int      uint16_t;
           =2 typedef unsigned long int       uint32_t;
           =2 #ifdef __SDCC_LONGLONG
           =2 typedef unsigned long long int  uint64_t;
           =2 #endif
           =2 
           =2 /* Small types.  */
           =2 
           =2 /* Signed.  */
           =2 typedef signed char             int_least8_t;
           =2 typedef short int               int_least16_t;
           =2 typedef long int                int_least32_t;
           =2 #ifdef __SDCC_LONGLONG
           =2 typedef long long int           int_least64_t;
           =2 #endif
           =2 
           =2 /* Unsigned.  */
           =2 typedef unsigned char           uint_least8_t;
           =2 typedef unsigned short int      uint_least16_t;
           =2 typedef unsigned long int       uint_least32_t;
           =2 #ifdef __SDCC_LONGLONG
           =2 typedef unsigned long long int  uint_least64_t;
           =2 #endif
           =2 
           =2 /* Fast types.  */
           =2 
           =2 /* Signed.  */
           =2 typedef signed char             int_fast8_t;
           =2 typedef int                     int_fast16_t;
           =2 typedef long int                int_fast32_t;
           =2 #ifdef __SDCC_LONGLONG
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 7   

           =2 typedef long long int           int_fast64_t;
           =2 #endif
           =2 
           =2 /* Unsigned.  */
           =2 typedef unsigned char           uint_fast8_t;
           =2 typedef unsigned int            uint_fast16_t;
           =2 typedef unsigned long int       uint_fast32_t;
           =2 #ifdef __SDCC_LONGLONG
           =2 typedef unsigned long long int  uint_fast64_t;
           =2 #endif
           =2 
           =2 /* Types for `void *' pointers.  */
           =2 #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =2   typedef long int              intptr_t;
           =2   typedef unsigned long int     uintptr_t;
           =2 #else
           =2   typedef int                   intptr_t;
           =2   typedef unsigned int          uintptr_t;
           =2 #endif
           =2 
           =2 
           =2 /* Largest integral types.  */
           =2 #ifndef __SDCC_LONGLONG
           =2 typedef long int                intmax_t;
           =2 typedef unsigned long int       uintmax_t;
           =2 #else
           =2 typedef long long int           intmax_t;
           =2 typedef unsigned long long int  uintmax_t;
           =2 #endif
           =2 
           =2 /* Limits of integral types.  */
           =2 
           =2 /* Minimum of signed integral types.  */
           =2 #define INT8_MIN               (-128)
           =2 #define INT16_MIN              (-32767-1)
           =2 #define INT32_MIN              (-2147483647L-1)
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT64_MIN              (-9223372036854775807LL-1)
           =2 #endif
           =2 
           =2 /* Maximum of signed integral types.  */
           =2 #define INT8_MAX               (127)
           =2 #define INT16_MAX              (32767)
           =2 #define INT32_MAX              (2147483647L)
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT64_MAX              (9223372036854775807LL)
           =2 #endif
           =2 
           =2 /* Maximum of unsigned integral types.  */
           =2 #define UINT8_MAX              (255)
           =2 #define UINT16_MAX             (65535)
           =2 #define UINT32_MAX             (4294967295UL)
           =2 #ifdef __SDCC_LONGLONG
           =2 #define UINT64_MAX             (18446744073709551615ULL)
           =2 #endif
           =2 
           =2 /* Minimum of signed integral types having a minimum size.  */
           =2 #define INT_LEAST8_MIN         INT8_MIN
           =2 #define INT_LEAST16_MIN        INT16_MIN
           =2 #define INT_LEAST32_MIN        INT32_MIN
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT_LEAST64_MIN        INT64_MIN
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 8   

           =2 #endif
           =2 
           =2 /* Maximum of signed integral types having a minimum size.  */
           =2 #define INT_LEAST8_MAX         INT8_MAX
           =2 #define INT_LEAST16_MAX        INT16_MAX
           =2 #define INT_LEAST32_MAX        INT32_MAX
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT_LEAST64_MAX        INT64_MAX
           =2 #endif
           =2 
           =2 /* Maximum of unsigned integral types having a minimum size.  */
           =2 #define UINT_LEAST8_MAX        UINT8_MAX
           =2 #define UINT_LEAST16_MAX       UINT16_MAX
           =2 #define UINT_LEAST32_MAX       UINT32_MAX
           =2 #ifdef __SDCC_LONGLONG
           =2 #define UINT_LEAST64_MAX       UINT64_MAX
           =2 #endif
           =2 
           =2 /* Minimum of fast signed integral types having a minimum size.  */
           =2 #define INT_FAST8_MIN          INT8_MIN
           =2 #define INT_FAST16_MIN         INT16_MIN
           =2 #define INT_FAST32_MIN         INT32_MIN
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT_FAST64_MIN         INT64_MIN
           =2 #endif
           =2 
           =2 /* Maximum of fast signed integral types having a minimum size.  */
           =2 #define INT_FAST8_MAX          INT8_MAX
           =2 #define INT_FAST16_MAX         INT16_MAX
           =2 #define INT_FAST32_MAX         INT32_MAX
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT_FAST64_MAX         INT64_MAX
           =2 #endif
           =2 
           =2 /* Maximum of fast unsigned integral types having a minimum size.  */
           =2 #define UINT_FAST8_MAX         UINT8_MAX
           =2 #define UINT_FAST16_MAX        UINT16_MAX
           =2 #define UINT_FAST32_MAX        UINT32_MAX
           =2 #ifdef __SDCC_LONGLONG
           =2 #define UINT_FAST64_MAX        UINT64_MAX
           =2 #endif
           =2 
           =2 /* Values to test for integral types holding `void *' pointer.  */
           =2 #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =2 #define INTPTR_MIN             (-2147483647L-1)
           =2 #define INTPTR_MAX             (2147483647L)
           =2 #define UINTPTR_MAX            (4294967295UL)
           =2 #else
           =2 #define INTPTR_MIN             (-32767-1)
           =2 #define INTPTR_MAX             (32767)
           =2 #define UINTPTR_MAX            (65535)
           =2 #endif
           =2 
           =2 /* Minimum for largest signed integral type.  */
           =2 #ifndef __SDCC_LONGLONG
           =2 #define INTMAX_MIN             (-2147483647L-1)
           =2 #else
           =2 #define INTMAX_MIN             (-9223372036854775807LL-1)
           =2 #endif
           =2 
           =2 /* Maximum for largest signed integral type.  */
           =2 #ifndef __SDCC_LONGLONG
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 9   

           =2 #define INTMAX_MAX             (2147483647L)
           =2 #else
           =2 #define INTMAX_MAX             (9223372036854775807LL)
           =2 #endif
           =2 
           =2 /* Maximum for largest unsigned integral type.  */
           =2 #ifndef __SDCC_LONGLONG
           =2 #define UINTMAX_MAX            (4294967295UL)
           =2 #else
           =2 #define UINTMAX_MAX            (18446744073709551615ULL)
           =2 #endif
           =2 
           =2 /* Limits of other integer types.  */
           =2 
           =2 /* Limits of `ptrdiff_t' type.  */
           =2 #if defined (__SDCC_mcs51) || defined (__SDCC_ds390)
           =2 #define PTRDIFF_MIN           (-2147483647L-1)
           =2 #define PTRDIFF_MAX           (2147483647L)
           =2 #else
           =2 #define PTRDIFF_MIN           (-32767-1)
           =2 #define PTRDIFF_MAX           (32767)
           =2 #endif
           =2 
           =2 /* */
           =2 #define SIG_ATOMIC_MIN        (0)
           =2 #define SIG_ATOMIC_MAX        (255)
           =2 
           =2 /* Limit of `size_t' type.  */
           =2 #define SIZE_MAX               (65535u)
           =2 
           =2 /* Signed.  */
           =2 #define INT8_C(c)      c
           =2 #define INT16_C(c)     c
           =2 #define INT32_C(c)     c ## L
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INT64_C(c)     c ## LL
           =2 #endif
           =2 
           =2 /* Unsigned.  */
           =2 #define UINT8_C(c)     c ## U
           =2 #define UINT16_C(c)    c ## U
           =2 #define UINT32_C(c)    c ## UL
           =2 #ifdef __SDCC_LONGLONG
           =2 #define UINT64_C(c)    c ## ULL
           =2 #endif
           =2 
           =2 #define WCHAR_MIN      0
           =2 #define WCHAR_MAX      0xffffffff
           =2 
           =2 #define WINT_MIN       0
           =2 #define WINT_MAX       0xffffffff
           =2 
           =2 /* Maximal type.  */
           =2 #ifdef __SDCC_LONGLONG
           =2 #define INTMAX_C(c)    c ## LL
           =2 #define UINTMAX_C(c)   c ## ULL
           =2 #else
           =2 #define INTMAX_C(c)    c ## L
           =2 #define UINTMAX_C(c)   c ## UL
           =2 #endif
           =2 
           =2 /* Bounds-checking interfaces from annex K of the C11 standard. */
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 10  

           =2 #if defined (__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__
           =2 #define RSIZE_MAX SIZE_MAX
           =2 #endif
           =2 
           =2 #endif /* stdint.h */
 274      =2  
   6      =1  
   7      =1  /* slave address 1 - 255 */
   8      =1  #define DIR 0x05    //slave dir 5d
   9      =1  
  10      =1  /* data range */
  11      =1  #define MAX_COILS 1
  12      =1  #define MAX_INPUTS 1
  13      =1  #define MAX_HOLDING_REGISTERS 2
  14      =1  #define MAX_INPUTS_REGISTERS 2
  15      =1  
  16      =1  /* internal slave memory data */
  17      =1  extern uint8_t idata coils_array[MAX_COILS]; 
  18      =1  extern uint8_t idata inputs_array[MAX_INPUTS];
  19      =1  extern uint16_t idata holding_registers_array[MAX_HOLDING_REGISTERS];
  20      =1  extern uint16_t idata inputs_registers_array[MAX_INPUTS_REGISTERS];
  21      =1  
  22      =1  /* functions prototypes */
  23      =1  uint8_t GetCoilValue(uint16_t adr);
  24      =1  void SetCoilValue(uint16_t adr, uint8_t value);
  25      =1  uint8_t GetInputValue(uint16_t adr);
  26      =1  uint16_t GetHoldingRegisterValue(uint16_t);
  27      =1  void SetHoldingRegisterValue(uint16_t, uint16_t);
  28      =1  uint16_t GetInputRegisterValue(uint16_t);
  29      =1  
  30      =1  
  31      =1  #endif  //__MODBUS_SLAVE_H__
   3          
   4          
   5          /* internal slave memory data */
   6          uint8_t idata coils_array[MAX_COILS]; 
   7          uint8_t idata inputs_array[MAX_INPUTS];
   8          uint16_t idata holding_registers_array[MAX_HOLDING_REGISTERS];
   9          uint16_t idata inputs_registers_array[MAX_INPUTS_REGISTERS];
  10          
  11          
  12          /* functions codes */
  13          /* coils read-write operations */
  14          uint8_t GetCoilValue(uint16_t adr)
  15          {
  16   1          uint8_t res = 0, i = 0, d = 0;
  17   1      
  18   1          if (adr < 0 || adr >= MAX_COILS * 8)
  19   1          {
  20   2              return 0;
  21   2          }
  22   1          i = adr / 8;
  23   1          d = adr % 8;
  24   1          res = (coils_array[i] & (1 << d));
  25   1          return res > 0;
  26   1      }
  27          
  28          void SetCoilValue(uint16_t adr, uint8_t value)
  29          {
  30   1          uint8_t res = 0, i = 0, d = 0;
  31   1      
  32   1          if (adr < 0 || adr >= MAX_COILS * 8)
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 11  

  33   1          {
  34   2              return;
  35   2          }
  36   1          i = adr / 8;
  37   1          d = adr % 8;
  38   1          res = (coils_array[i] & (1 << d));
  39   1          if (res > 0)
  40   1          {
  41   2              res = 1; // coil on
  42   2          }
  43   1          else
  44   1          {
  45   2              res = 0; // coil off
  46   2          }
  47   1          if (res == 1 && value == 1)
  48   1          {
  49   2              return; // already ON
  50   2          }
  51   1          if (res == 0 && value == 0)
  52   1          {
  53   2              return; // already OFF
  54   2          }
  55   1          if (res == 0 && value == 1) // is off turn on
  56   1          {
  57   2              coils_array[i] = (coils_array[i] | (1 << d)); // active coil
  58   2          }
  59   1          if (res == 1 && value == 0) // is on turn off
  60   1          {
  61   2              coils_array[i] = (coils_array[i] & (~(1 << d))); // desactive coil
  62   2          }
  63   1          return;
  64   1      }
  65          
  66          /* holding registers read-write operations */
  67          uint16_t GetHoldingRegisterValue(uint16_t adr)
  68          {
  69   1          if (adr < 0 || adr >= MAX_HOLDING_REGISTERS)
  70   1          {
  71   2              return 0; // invalid register address
  72   2          }
  73   1          else
  74   1          {
  75   2              return holding_registers_array[adr];
  76   2          }
  77   1      }
  78          
  79          void SetHoldingRegisterValue(uint16_t adr, uint16_t value)
  80          {
  81   1          if (adr < 0 || adr >= MAX_HOLDING_REGISTERS || value < 0 || value > 65535)
  82   1          {
  83   2              return; // invalid register address
  84   2          }
  85   1          else
  86   1          {
  87   2              holding_registers_array[adr] = value;
  88   2          }
  89   1      }
  90          
  91          /* inputs read-only operations */
  92          uint8_t GetInputValue(uint16_t adr)
  93          {
  94   1          uint8_t res = 0, i = 0, d = 0;
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 12  

  95   1      
  96   1          if (adr < 0 || adr >= MAX_INPUTS * 8)
  97   1          {
  98   2              return 0;
  99   2          }
 100   1          i = adr / 8;
 101   1          d = adr % 8;
 102   1          res = (inputs_array[i] & (1 << d));
 103   1          return res > 0;
 104   1      }
 105          
 106          uint16_t GetInputRegisterValue(uint16_t adr)
 107          {
 108   1          if (adr < 0 || adr >= MAX_INPUTS_REGISTERS)
 109   1          {
 110   2              return 0; // invalid register address
 111   2          }
 112   1          else
 113   1          {
 114   2              return inputs_registers_array[adr];
 115   2          }
 116   1      }
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 13  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _GetCoilValue (BEGIN)
                                           ; SOURCE LINE # 14
;---- Variable 'adr' assigned to Register 'R4/R5' ----
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 15
                                           ; SOURCE LINE # 16
;---- Variable 'res' assigned to Register 'R7' ----
0004 E4                CLR     A
0005 FF                MOV     R7,A
;---- Variable 'i' assigned to Register 'R6' ----
;---- Variable 'd' assigned to Register 'R3' ----
0006 FB                MOV     R3,A
                                           ; SOURCE LINE # 18
0007 C3                CLR     C
0008 EC                MOV     A,R4
0009 9400              SUBB    A,#00H
000B 4008              JC      ?C0002
000D ED                MOV     A,R5
000E 9408              SUBB    A,#08H
0010 EC                MOV     A,R4
0011 9400              SUBB    A,#00H
0013 4003              JC      ?C0001
0015         ?C0002:
                                           ; SOURCE LINE # 19
                                           ; SOURCE LINE # 20
0015 7F00              MOV     R7,#00H
0017 22                RET     
                                           ; SOURCE LINE # 21
0018         ?C0001:
                                           ; SOURCE LINE # 22
0018 AE04              MOV     R6,AR4
001A ED                MOV     A,R5
001B 7803              MOV     R0,#03H
001D         ?C0032:
001D CE                XCH     A,R6
001E C3                CLR     C
001F 13                RRC     A
0020 CE                XCH     A,R6
0021 13                RRC     A
0022 D8F9              DJNZ    R0,?C0032
0024 FE                MOV     R6,A
                                           ; SOURCE LINE # 23
0025 ED                MOV     A,R5
0026 5407              ANL     A,#07H
0028 FB                MOV     R3,A
                                           ; SOURCE LINE # 24
0029 FF                MOV     R7,A
002A F8                MOV     R0,A
002B 7401              MOV     A,#01H
002D 08                INC     R0
002E 8002              SJMP    ?C0034
0030         ?C0033:
0030 C3                CLR     C
0031 33                RLC     A
0032         ?C0034:
0032 D8FC              DJNZ    R0,?C0033
0034 FF                MOV     R7,A
0035 7400        R     MOV     A,#LOW coils_array
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 14  

0037 2E                ADD     A,R6
0038 F8                MOV     R0,A
0039 EF                MOV     A,R7
003A 56                ANL     A,@R0
                                           ; SOURCE LINE # 25
003B D3                SETB    C
003C 9400              SUBB    A,#00H
003E 7480              MOV     A,#080H
0040 9480              SUBB    A,#080H
0042 4004              JC      ?C0004
0044 7F01              MOV     R7,#01H
0046 8002              SJMP    ?C0005
0048         ?C0004:
0048 7F00              MOV     R7,#00H
004A         ?C0005:
                                           ; SOURCE LINE # 26
004A         ?C0003:
004A 22                RET     
             ; FUNCTION _GetCoilValue (END)

             ; FUNCTION _SetCoilValue (BEGIN)
                                           ; SOURCE LINE # 28
0000 8E00        R     MOV     adr,R6
0002 8F00        R     MOV     adr+01H,R7
;---- Variable 'value' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 29
                                           ; SOURCE LINE # 30
;---- Variable 'res' assigned to Register 'R7' ----
0004 E4                CLR     A
0005 FF                MOV     R7,A
;---- Variable 'i' assigned to Register 'R6' ----
;---- Variable 'd' assigned to Register 'R4' ----
0006 FC                MOV     R4,A
                                           ; SOURCE LINE # 32
0007 C3                CLR     C
0008 E500        R     MOV     A,adr
000A 9400              SUBB    A,#00H
000C 5003              JNC     $ + 5H
000E 020000      R     LJMP    ?C0008
0011 E500        R     MOV     A,adr+01H
0013 9408              SUBB    A,#08H
0015 E500        R     MOV     A,adr
0017 9400              SUBB    A,#00H
0019 507B              JNC     ?C0008
                                           ; SOURCE LINE # 33
                                           ; SOURCE LINE # 35
                                           ; SOURCE LINE # 36
001B AE00        R     MOV     R6,adr
001D E500        R     MOV     A,adr+01H
001F 7803              MOV     R0,#03H
0021         ?C0035:
0021 CE                XCH     A,R6
0022 C3                CLR     C
0023 13                RRC     A
0024 CE                XCH     A,R6
0025 13                RRC     A
0026 D8F9              DJNZ    R0,?C0035
0028 FE                MOV     R6,A
                                           ; SOURCE LINE # 37
0029 E500        R     MOV     A,adr+01H
002B 5407              ANL     A,#07H
002D FC                MOV     R4,A
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 15  

                                           ; SOURCE LINE # 38
002E F8                MOV     R0,A
002F 7401              MOV     A,#01H
0031 08                INC     R0
0032 8002              SJMP    ?C0037
0034         ?C0036:
0034 C3                CLR     C
0035 33                RLC     A
0036         ?C0037:
0036 D8FC              DJNZ    R0,?C0036
0038 FF                MOV     R7,A
0039 7400        R     MOV     A,#LOW coils_array
003B 2E                ADD     A,R6
003C F8                MOV     R0,A
003D E6                MOV     A,@R0
003E F9                MOV     R1,A
003F 5F                ANL     A,R7
                                           ; SOURCE LINE # 39
0040 D3                SETB    C
0041 9400              SUBB    A,#00H
0043 7480              MOV     A,#080H
0045 9480              SUBB    A,#080H
0047 4004              JC      ?C0009
                                           ; SOURCE LINE # 40
                                           ; SOURCE LINE # 41
0049 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 42
004B 8002              SJMP    ?C0010
004D         ?C0009:
                                           ; SOURCE LINE # 44
                                           ; SOURCE LINE # 45
004D E4                CLR     A
004E FF                MOV     R7,A
                                           ; SOURCE LINE # 46
004F         ?C0010:
                                           ; SOURCE LINE # 47
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 7005              JNZ     ?C0011
0054 ED                MOV     A,R5
0055 6401              XRL     A,#01H
0057 603D              JZ      ?C0008
                                           ; SOURCE LINE # 48
                                           ; SOURCE LINE # 50
0059         ?C0011:
                                           ; SOURCE LINE # 51
0059 EF                MOV     A,R7
005A 7003              JNZ     ?C0012
005C ED                MOV     A,R5
005D 6037              JZ      ?C0008
                                           ; SOURCE LINE # 52
                                           ; SOURCE LINE # 54
005F         ?C0012:
                                           ; SOURCE LINE # 55
005F EF                MOV     A,R7
0060 7017              JNZ     ?C0013
0062 ED                MOV     A,R5
0063 6401              XRL     A,#01H
0065 7012              JNZ     ?C0013
                                           ; SOURCE LINE # 56
                                           ; SOURCE LINE # 57
0067 A804              MOV     R0,AR4
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 16  

0069 04                INC     A
006A 08                INC     R0
006B 8002              SJMP    ?C0039
006D         ?C0038:
006D C3                CLR     C
006E 33                RLC     A
006F         ?C0039:
006F D8FC              DJNZ    R0,?C0038
0071 FB                MOV     R3,A
0072 7400        R     MOV     A,#LOW coils_array
0074 2E                ADD     A,R6
0075 F8                MOV     R0,A
0076 EB                MOV     A,R3
0077 49                ORL     A,R1
0078 F6                MOV     @R0,A
                                           ; SOURCE LINE # 58
0079         ?C0013:
                                           ; SOURCE LINE # 59
0079 EF                MOV     A,R7
007A 6401              XRL     A,#01H
007C 7018              JNZ     ?C0008
007E ED                MOV     A,R5
007F 7015              JNZ     ?C0008
                                           ; SOURCE LINE # 60
                                           ; SOURCE LINE # 61
0081 AF04              MOV     R7,AR4
0083 A807              MOV     R0,AR7
0085 04                INC     A
0086 08                INC     R0
0087 8002              SJMP    ?C0041
0089         ?C0040:
0089 C3                CLR     C
008A 33                RLC     A
008B         ?C0041:
008B D8FC              DJNZ    R0,?C0040
008D F4                CPL     A
008E FF                MOV     R7,A
008F 7400        R     MOV     A,#LOW coils_array
0091 2E                ADD     A,R6
0092 F8                MOV     R0,A
0093 EF                MOV     A,R7
0094 56                ANL     A,@R0
0095 F6                MOV     @R0,A
                                           ; SOURCE LINE # 62
                                           ; SOURCE LINE # 64
0096         ?C0008:
0096 22                RET     
             ; FUNCTION _SetCoilValue (END)

             ; FUNCTION _GetHoldingRegisterValue (BEGIN)
                                           ; SOURCE LINE # 67
;---- Variable 'adr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 68
                                           ; SOURCE LINE # 69
0000 C3                CLR     C
0001 EE                MOV     A,R6
0002 9400              SUBB    A,#00H
0004 4008              JC      ?C0016
0006 EF                MOV     A,R7
0007 9402              SUBB    A,#02H
0009 EE                MOV     A,R6
000A 9400              SUBB    A,#00H
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 17  

000C 4004              JC      ?C0015
000E         ?C0016:
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 71
000E E4                CLR     A
000F FE                MOV     R6,A
0010 FF                MOV     R7,A
0011 22                RET     
                                           ; SOURCE LINE # 72
0012         ?C0015:
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 75
0012 EF                MOV     A,R7
0013 25E0              ADD     A,ACC
0015 2400        R     ADD     A,#LOW holding_registers_array
0017 F8                MOV     R0,A
0018 E6                MOV     A,@R0
0019 FE                MOV     R6,A
001A 08                INC     R0
001B E6                MOV     A,@R0
001C FF                MOV     R7,A
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
001D         ?C0017:
001D 22                RET     
             ; FUNCTION _GetHoldingRegisterValue (END)

             ; FUNCTION _SetHoldingRegisterValue (BEGIN)
                                           ; SOURCE LINE # 79
0000 8E00        R     MOV     adr,R6
0002 8F00        R     MOV     adr+01H,R7
;---- Variable 'value' assigned to Register 'DPTR' ----
0004 8D82              MOV     DPL,R5
0006 8C83              MOV     DPH,R4
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0008 C3                CLR     C
0009 E500        R     MOV     A,adr
000B 9400              SUBB    A,#00H
000D 402F              JC      ?C0021
000F E500        R     MOV     A,adr+01H
0011 9402              SUBB    A,#02H
0013 E500        R     MOV     A,adr
0015 9400              SUBB    A,#00H
0017 5025              JNC     ?C0021
0019 C3                CLR     C
001A E583              MOV     A,DPH
001C 9400              SUBB    A,#00H
001E 401E              JC      ?C0021
0020 AF82              MOV     R7,DPL
0022 AE83              MOV     R6,DPH
0024 E4                CLR     A
0025 FC                MOV     R4,A
0026 FD                MOV     R5,A
0027 7BFF              MOV     R3,#0FFH
0029 7AFF              MOV     R2,#0FFH
002B F9                MOV     R1,A
002C F8                MOV     R0,A
002D 120000      E     LCALL   ?C?SLCMP
0030 400C              JC      ?C0021
                                           ; SOURCE LINE # 82
                                           ; SOURCE LINE # 84
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 18  

                                           ; SOURCE LINE # 86
                                           ; SOURCE LINE # 87
0032 E500        R     MOV     A,adr+01H
0034 25E0              ADD     A,ACC
0036 2400        R     ADD     A,#LOW holding_registers_array
0038 F8                MOV     R0,A
0039 A683              MOV     @R0,DPH
003B 08                INC     R0
003C A682              MOV     @R0,DPL
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 89
003E         ?C0021:
003E 22                RET     
             ; FUNCTION _SetHoldingRegisterValue (END)

             ; FUNCTION _GetInputValue (BEGIN)
                                           ; SOURCE LINE # 92
;---- Variable 'adr' assigned to Register 'R4/R5' ----
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
;---- Variable 'res' assigned to Register 'R7' ----
0004 E4                CLR     A
0005 FF                MOV     R7,A
;---- Variable 'i' assigned to Register 'R6' ----
;---- Variable 'd' assigned to Register 'R3' ----
0006 FB                MOV     R3,A
                                           ; SOURCE LINE # 96
0007 C3                CLR     C
0008 EC                MOV     A,R4
0009 9400              SUBB    A,#00H
000B 4008              JC      ?C0024
000D ED                MOV     A,R5
000E 9408              SUBB    A,#08H
0010 EC                MOV     A,R4
0011 9400              SUBB    A,#00H
0013 4003              JC      ?C0023
0015         ?C0024:
                                           ; SOURCE LINE # 97
                                           ; SOURCE LINE # 98
0015 7F00              MOV     R7,#00H
0017 22                RET     
                                           ; SOURCE LINE # 99
0018         ?C0023:
                                           ; SOURCE LINE # 100
0018 AE04              MOV     R6,AR4
001A ED                MOV     A,R5
001B 7803              MOV     R0,#03H
001D         ?C0042:
001D CE                XCH     A,R6
001E C3                CLR     C
001F 13                RRC     A
0020 CE                XCH     A,R6
0021 13                RRC     A
0022 D8F9              DJNZ    R0,?C0042
0024 FE                MOV     R6,A
                                           ; SOURCE LINE # 101
0025 ED                MOV     A,R5
0026 5407              ANL     A,#07H
0028 FB                MOV     R3,A
                                           ; SOURCE LINE # 102
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 19  

0029 FF                MOV     R7,A
002A F8                MOV     R0,A
002B 7401              MOV     A,#01H
002D 08                INC     R0
002E 8002              SJMP    ?C0044
0030         ?C0043:
0030 C3                CLR     C
0031 33                RLC     A
0032         ?C0044:
0032 D8FC              DJNZ    R0,?C0043
0034 FF                MOV     R7,A
0035 7400        R     MOV     A,#LOW inputs_array
0037 2E                ADD     A,R6
0038 F8                MOV     R0,A
0039 EF                MOV     A,R7
003A 56                ANL     A,@R0
                                           ; SOURCE LINE # 103
003B D3                SETB    C
003C 9400              SUBB    A,#00H
003E 7480              MOV     A,#080H
0040 9480              SUBB    A,#080H
0042 4004              JC      ?C0026
0044 7F01              MOV     R7,#01H
0046 8002              SJMP    ?C0027
0048         ?C0026:
0048 7F00              MOV     R7,#00H
004A         ?C0027:
                                           ; SOURCE LINE # 104
004A         ?C0025:
004A 22                RET     
             ; FUNCTION _GetInputValue (END)

             ; FUNCTION _GetInputRegisterValue (BEGIN)
                                           ; SOURCE LINE # 106
;---- Variable 'adr' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 108
0000 C3                CLR     C
0001 EE                MOV     A,R6
0002 9400              SUBB    A,#00H
0004 4008              JC      ?C0029
0006 EF                MOV     A,R7
0007 9402              SUBB    A,#02H
0009 EE                MOV     A,R6
000A 9400              SUBB    A,#00H
000C 4004              JC      ?C0028
000E         ?C0029:
                                           ; SOURCE LINE # 109
                                           ; SOURCE LINE # 110
000E E4                CLR     A
000F FE                MOV     R6,A
0010 FF                MOV     R7,A
0011 22                RET     
                                           ; SOURCE LINE # 111
0012         ?C0028:
                                           ; SOURCE LINE # 113
                                           ; SOURCE LINE # 114
0012 EF                MOV     A,R7
0013 25E0              ADD     A,ACC
0015 2400        R     ADD     A,#LOW inputs_registers_array
0017 F8                MOV     R0,A
0018 E6                MOV     A,@R0
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 20  

0019 FE                MOV     R6,A
001A 08                INC     R0
001B E6                MOV     A,@R0
001C FF                MOV     R7,A
                                           ; SOURCE LINE # 115
                                           ; SOURCE LINE # 116
001D         ?C0030:
001D 22                RET     
             ; FUNCTION _GetInputRegisterValue (END)

C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 21  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
_GetInputRegisterValue . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
int_least32_t. . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int_least16_t. . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int16_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
uint_fast32_t. . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint_fast16_t. . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
int_fast32_t . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int_fast16_t . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
coils_array. . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0000H  1
inputs_array . . . . . . . . . . . . .  PUBLIC   IDATA  ARRAY    0001H  1
_GetCoilValue. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  res. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  d. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
holding_registers_array. . . . . . . .  PUBLIC   IDATA  ARRAY    0002H  4
_GetInputValue . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0004H  2
  res. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  d. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0003H  1
_GetHoldingRegisterValue . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
_SetCoilValue. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  res. . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  d. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0004H  1
_SetHoldingRegisterValue . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  adr. . . . . . . . . . . . . . . . .  AUTO     DATA   U_INT    0000H  2
  value. . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0082H  2
uint_least8_t. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
int_least8_t . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
uintmax_t. . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint_fast8_t . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
inputs_registers_array . . . . . . . .  PUBLIC   IDATA  ARRAY    0006H  4
intmax_t . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
int_fast8_t. . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
uintptr_t. . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
intptr_t . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
uint_least32_t . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
uint_least16_t . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    424    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =     10    ----
C51 COMPILER V9.60.0.0   SLAVE                                                             10/13/2022 12:12:50 PAGE 22  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
